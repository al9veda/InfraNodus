<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimal-ui">
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/jquery.textcomplete.css' />
    <link rel="stylesheet" href="/stylesheets/side-menu.css">
    <link rel="stylesheet" href="/stylesheets/jquery-ui.min.css">
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <link rel='stylesheet' href='/stylesheets/jquery.taghandler.css' />
    <link rel='stylesheet' href='/stylesheets/jquery.content-panel-switcher.css' />
    <script src="/javascripts/jquery.content-panel-switcher.js"></script>
    <link rel="stylesheet" type="text/css" href="/stylesheets/tooltipster.css" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/tooltipster-noir.css" />



</head>
<body>
<% include statsabove %>
<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
    <!-- Hamburger icon -->
    <span></span>
    </a>
     <div id="menu">
        <div class="pure-menu pure-menu-open">
        <% if (locals.user || perceivername) { %>
            <% if (perceivername) { %>
            <a class="pure-menu-heading" href="/<%= perceivername %>"><%= perceivername %></a>
            <% } else { %>
            <a class="pure-menu-heading" href="/<%= user.name %>/edit"><%= user.name %></a>
            <% } %>
                <br>
                <ul id="contexts" class="contexts">

                </ul>
            &nbsp;<br><br>

        <% } else { %>
            <% include menu %>

        <% } %>
        </div>
   </div>
     <div id='content'>
             <div id='statements'>

                 <div id="entries">

                     <% entries.forEach(function(entry) { %>
                     <div class='entry' data-uid='<%= entry.uid %>' data-timestamp='<%= entry.timestamp %>' data-hashtags='<%= entry.name %>'>
                         <p class='entry-text'><%- entry.text %></p>
                         <p class='entry-date'><%= entry.timestamp %></p>
                         <p class='entry-menu'>&nbsp;&nbsp;&nbsp;<a class="app-link-menu" href="#">show filtered</a></p>
                         <div class='separator'>&nbsp;</div>
                         <div id='<%= entry.uid %>' class='hidden'></div>
                     </div>
                     <% }) %>


                     <% include messages %>
                     <div id="warnings"></div>
                     <div id="messages"></div>
             </div>


              <div id="entryform">



       <% if (!perceivername) { %>

            <div id='switcher-selector' class='pure-menu pure-menu-open pure-menu-horizontal' style="background: none;">
                <ul id="topmenuitems">

                    <li>
                        <a id="finds" class="switcher set1">find</a>
                    </li>
                    <li class="pure-menu-selected-top">
                        <a id="adds" class="switcher set1">add</a>
                    </li>
                    <li>
                        <a id="imports" href="/import?context=<%= context %>">import</a>
                    </li>



                </ul>

                <br>&nbsp;<br>

            </div>


            <% }  %>

                  <a href="javascript:" id="graph-link">
                      <span></span>
                  </a>
                  <a href="javascript:" id="windowdown-link">
                      <span></span>
                  </a>
                  <% if (!perceivername) { %>
                  <a href="javascript:" id="collaborate-link">
                      <!-- Collaborate icon -->
                      <span></span>
                  </a>
                  <% } %>

                  <% if (contextpublic && context && !perceivername && entries.length > 0) { %>
                  <a href="javascript:" id="privacy-link" class="is-public">
                      <!-- Share icon -->
                      <span></span>
                  </a>
                  <% } else if (!perceivername && context && entries.length > 0) { %>
                  <a href="javascript:" id="privacy-link">
                      <!-- Share icon -->
                      <span></span>
                  </a>
                  <% } %>

                  <% if ((context && entries.length > 2) && (!perceivername)) { %>
                  <form action='/post' name='deletecontext' id="deletecontext" method='post' class='pure-form' onsubmit="return confirm('Deleting the context will delete all the statements inside. Are you sure?');">

                      <input type="hidden" name="context" value="<%= context %>">
                      <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
                      <input type="hidden" name="statementid" value="">
                      &nbsp;<br>
                      <input type='submit' id="deletecontextbutton" name="delete" value="delete context">

                  </form>
                  <% } %>






                  <!-- the panel to show content -->

            <div id="switcher-panel"></div>

            <!-- form to add, later do import here -->
            <% if (!perceivername) { %>
            <div id="adds-content" class="switcher-content set1 show">
            <% } else { %>
            <div id="adds-content" class="switcher-content set1">
            <% } %>
                <form action='/post' name='submitform' id="submitform" method='post' class='pure-form'>

                        <textarea columns="40" rows="4" name='entry[body]' id="statement" placeholder='type in some words or #hashtags to see how they connect'><% if (url) { %><%= urltitle %> <%= url %><% } %></textarea>
                        <div id="addToContextsLabel">sets:</div>
                        <ul id="addToContexts"></ul>
                        <input type="hidden" id="addedContexts" name="addedContexts">
                        <input type="hidden" id="context" name="context" value="<%= context %>">
                        <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
                        <input type="hidden" id="statementid" name="statementid" value="">
                        <input type="hidden" name="timestamp" value="">
                        &nbsp;<br>
                        <input type='submit' id="submitbutton" name="btnSubmit" value="save" class="pure-button pure-button-primary">

                </form>

            </div>



            <!-- form to find -->
            <% if (perceivername) { %>
                <div id="finds-content" class="switcher-content set1 show">
            <% } else { %>
                <div id="finds-content" class="switcher-content set1">
            <% } %>
                <form class="pure-form" id="searchform">
                    <input type="text" id="search" size="14" maxlength="20" class="pure-input" placeholder="search...">
                    &nbsp;&nbsp;
                    <input type='submit' name="submit" value=">" class="pure-button pure-button-primary">
             </form>
            </div>
          </div>
        </div>

        <div id="graph-container"></div>


                <a href="javascript:" id="chat-link" title="show / hide the text">
                    <!-- Chat icon -->
                    <span></span>
                </a>
        <div id="controls">
                <div id="graph-reload">
                <a href="javascript:" id="go_next"><img src="/images/eyezoom.png"  title="choose a few nodes from the graph and click this button to find out more" vspace="0" border="0"></a><br><a href="javascript:location.reload();"><img src="/images/reload.png" title="clear and reload graph" vspace="6" border="0"></a><br><a href="javascript:" id="improve-layout"><img src="/images/diamond.png" title="improve graph layout" vspace="3" border="0"></a>

        </div>

        <div id="graph-tools">
                <a href="javascript:" id="zoom-in"><img src="/images/zoom-in.png" border="0"></a><br><a href="javascript:" id="zoom-out"><img src="/images/zoom-out.png" border="0"></a>
         </div>
            <% if (!perceivername) { %>
                <a href="javascript:" id="microphone-link" class="tooltip" title="voice to text on/off">
                    <!-- Microphone icon -->
                    <span></span>
                </a>
            <% } %>
      </div>

    </div>




</div>

<script src="/javascripts/sigma/sigma.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.parsers.json.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.layout.forceAtlas2.js"></script>
<script src="/javascripts/sigma/plugins/sigma.plugins.animate.min.js"></script>
<script src="/javascripts/jquery.min.js"></script>
<script src="/javascripts/jquery-ui.min.js"></script>
<script src="/javascripts/string.min.js"></script>
<script src="/javascripts/underscore-min.js"></script>
<script src="/javascripts/jquery.textcomplete.js"></script>
<script src='/javascripts/jquery.autosize.js'></script>
<script src="/javascripts/ui.js"></script>
<script src="/javascripts/jquery.mobile-events.min.js"></script>
<script src="/javascripts/jquery.highlight-4.js"></script>
<script src="/javascripts/bundle-stemmer.js"></script>
<script src="/javascripts/jquery.taghandler.js"></script>
<script src="/javascripts/socket.io.js"></script>
<script src="/javascripts/moment.min.js"></script>
<script type="text/javascript" src="/javascripts/jquery.tooltipster.min.js"></script>




             <script>
;(function(){

    var urlPath = location.pathname;

    // Initialize Socket.IO
    var socket = io();



    // Get URL variables in the form of an array

    function getUrlVars()
    {
        var vars = [], hash;
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
        for(var i = 0; i < hashes.length; i++)
        {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
        }
        return vars;
    }



    // First we query URL parameters

    /* {

     Which queries to add to search keywords from the graph:
     "go_next_add": "keyword",
     Which website to refer people to with the keywords (include search string with URL)
     "go_next_url" : "http://soundcloud.com/search?q="
     }

     */

    var forwardTo = 'https://www.google.com/search?q=';

    var go_next_url = getUrlVars()["go_next_url"];

    var go_next_site = getUrlVars()["go_next_site"];

    var go_next_add = getUrlVars()["go_next_add"];

    var go_next_override = getUrlVars()["go_next_override"];

    var link_hashtags = getUrlVars()["link_hashtags"];

    var convert_hashtags = getUrlVars()["convert_hashtags"];

    var hide_always = getUrlVars()["hide_always"];

    var hide_when_small = getUrlVars()["hide_when_small"];

    var language = getUrlVars()["language"];

    var mute = getUrlVars()["mute"];

    if (go_next_url) {
        if ((go_next_url.substr(go_next_url.length - 1) == 's' || go_next_url.substr(go_next_url.length - 6) == 'search' || go_next_url.substr(go_next_url.length - 5) == 'query')) {
           go_next_url = go_next_url + '=';
        }
        forwardTo = go_next_url;
    }
    else if (go_next_site == 'soundcloud') {
        forwardTo = 'https://soundcloud.com/search?q=';
    }
    else if (go_next_site == 'youtube') {
        forwardTo = 'https://www.youtube.com/results?search_query=';
    }
    else if (go_next_site == 'wikipedia') {
        forwardTo = 'https://wikipedia.org/wiki/Special:Search?search=';
    }
    else if (go_next_site == 'amazon') {
        forwardTo = 'http://www.amazon.com/s/field-keywords=';
    }
    else if (go_next_site == 'twitter') {
        forwardTo = 'http://twitter.com/search?q=';
    }

    // For collaboration - Socket.IO chat
    var collaborate_invite = getUrlVars()["collaborate"];



// MAIN SETTINGS START

// Create node ID - Name index for filtering
var nodeIDs = [];

// What are the concepts displayed - the opposite of above
var nodeNames = [];

// Let's record all the unique edges we've got

var edgesList = [];

// Create context-node index for filtering
var contextNodeID = [];

// Create statement-node index for filtering
var nodesOfStatement = [];

// What are the concepts present in the graph?
var contextNames = [];

// What are the concepts present in the graph?
var statementsOfContext = [];

var current_context_field = [];

var jsonpath = '';

var addcontext = '';

// Path to the JSON graph file (specific context or a general one)
    <% if (addcontext) { %>
        jsonpath = '/api/user/nodes/<%= context %>?addcontext=<%= addcontext %>';
        addcontext = "<%= addcontext %>";

    <% } else if (showcontexts) { %>
        jsonpath = '/api/user/nodes/<%= context %>?showcontexts=<%= showcontexts %>';
        addcontext = "";

    <% } else { %>
        jsonpath = '/api/user/nodes/<%= context %>';
        addcontext = "";
    <% }  %>


// Is the user going to look at somebody else's graph?

    <% if (perceivername) { %>
        <% if (showcontexts && maxnodes) { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>&maxnodes=<%= maxnodes %>';
        <% } else if (showcontexts) { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>';
        <% } else if (maxnodes) { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= maxnodes %>';
        <% } else  { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>';
    <% } %>
    <% } %>


// Get current context
var path = window.location.pathname;
var current_context = '<%= context %>';
var current_user = path.replace(/^\/([^\/]*).*$/, '$1');
var hostsite = window.location.host;


// These are the nodes clicked in the graph
var pinnedNodes = [];
var splicedNodes = [];
var notfoundNodes = [];

// Whats the clicked nodes in the graph
var clickedNodes = [];

// Inactivity timeout
var inactiveTimeout = null;

// This variable shows if there was a meaningful interaction with the graph yet
var graphInteraction = null;

// Loaded with graph only?
var graphOnly = null;


// Who posted the message?
var selfPosted = null;


// Socket.IO chat collaborate

// This matrix relates each URL path to each unique chat that can happen within that room

var collaborate_matrix = {};

var collaborate_room = urlPath + '/';

var collaborate_id = '';

var collaborate_content = '';

var collaborate_message = '';

var collaborate_html = '';

var collaborate_storage = JSON.parse(localStorage.getItem("collaborate"));

// If the user opened a URL with collaborate=xxxxxx then they join the room that's the "url_path/xxxxxx"
if (collaborate_invite) {
    collaborate_id = collaborate_invite;
}
// Otherwise they join a room which is "url_path/randomnumber"
else {
    collaborate_id = Math.round((Math.random() * 1000000));
}

collaborate_matrix[collaborate_room] = collaborate_room + collaborate_id;


if (!collaborate_invite) {
    if (collaborate_storage) {

        if (collaborate_storage[collaborate_room]) {
            if (collaborate_storage[collaborate_room].length > 0) {
                collaborate_matrix[collaborate_room] = collaborate_storage[collaborate_room];
                collaborate_id = collaborate_matrix[collaborate_room].split("/").pop();
            }
        }
    }

    // Now in case the original user reloads the page by error, they'll get the new collaborate ID, so we avoid that by storing their data
    localStorage.setItem("collaborate", JSON.stringify(collaborate_matrix));
}


    // On connection to server get the id of the current chat "room", which is actually the folder/URL of the current user

    socket.on('connect', function(){
        console.log('connected');
        socket.emit('login', {user: current_user, context: current_context, id: collaborate_matrix[collaborate_room]});
    });


    socket.on('startChat', function(data){
        console.log('chat started');
        if(data.boolean && data.id == collaborate_matrix[collaborate_room]) {
            console.log('in chat room ' + data.id);
            var collab_content = $('#collaborate-link').tooltipster('content');
            $('#collaborate-link').tooltipster('content', 'Collaboration is ON');
            $('#collaborate-link').addClass('is-collab');
            $('#collaborate-link').tooltipster('show');
            setTimeout(function() {
                $('#collaborate-link').tooltipster('hide');
                setTimeout(function() {
                    $('#collaborate-link').tooltipster('content', collab_content);
                }, 1000);

            }, 2000);
        }
    });

    socket.on('leave', function(msg){
        console.log('partner left');
        console.log(msg.people);
        $('#collaborate-link').removeClass('is-collab');
        var collab_content = $('#collaborate-link').tooltipster('content');
        $('#collaborate-link').tooltipster('content', 'Collaboration is OFF');
        $('#collaborate-link').tooltipster('show');
        setTimeout(function() {
            $('#collaborate-link').tooltipster('hide');
            setTimeout(function() {
                $('#collaborate-link').tooltipster('content', collab_content);
            }, 1000);
        }, 2000);
    });

    socket.on('tooMany', function(data){

        console.log('one too many');
        alert('There are already 2 users working on this set and this is our max so far. If you think it is a mistake, please, check if any of your extra browser tabs are opened.');
        window.location.href = 'http://' + hostsite + '/' + 'home' + '/edit';

    });





// The button to hide / show statements

$("#graph-link").click(function(e) {
    e.preventDefault();

    // The user clicked on the graph icon, so we reset his graph interaction activity for timeout later
    graphInteraction = null;
    clearTimeout(inactiveTimeout);

    toggle_statements();
});

    $("#windowdown-link").click(function(e) {
        e.preventDefault();
        if ((localStorage.getItem('folded') == 1)) {
            $('#entryform').css({top: 'auto', 'margin-top': '0px'});
            $('#entries').css({height:  $(window).height() - $('#entryform').height() - 75});
            $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
            $('#deletecontext').show();
            $('#privacy-link').show();
            $('#collaborate-link').show();
            localStorage.setItem('folded', 0);
        }
        else {
            $('#entryform').css({top:  $(window).height(), 'margin-top': '-50px'});
            $('#entries').css({height:  $(window).height() - 80});
            $('#deletecontext').hide();
            $('#privacy-link').hide();
            $('#collaborate-link').hide();
            localStorage.setItem('folded', 1);
        }


    });


    document.addEventListener("DOMContentLoaded", function(event) {


        submitFormProcess();


    });



function submitFormProcess() {

    document.querySelector('#submitform').addEventListener('submit', function(e) {

        e.preventDefault();


        $('#statement').addClass('loading');

        $('#submitbutton').attr('disabled', 'disabled');

        // We will set a user for posting. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
        var postedby = '';

        <% if (receivername) { %>
           postedby = '<%= receivername %>';
        <% } %>
        // TODO make it possible that those statements get submitted in both graphs

        // is urlvars mute off? then post as usual
        if (!mute) {
        $.post('/post', $("#submitform").serialize())
                .done(function(res) {
                    //3. Receive the server response, no need to emit an event
                    if (res.entryuid) {
                        //4. Show the updated text
                        selfPosted = '1';
                        $("#statement").val('');
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');
                        socket.emit('chat message', {postedby: postedby, entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                        // This function will see what it has to say
                        infraTalk(5000);
                    }
                    else if (res.errormsg) {
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');
                        alert(res.errormsg);
                    }
                    else {
                        alert('Something went wrong, please, try again...');
                    }
                })
                .fail(function(res) {
                    alert("Server Error: " + res.status + " " + res.statusText);
                });

        }
        // otherwise - make a dummy post - it appears in the list but doesn't get submitted into the graph
        else {
            selfPosted = '1';
            $('#statement').removeClass('loading');
            $('#submitbutton').removeAttr('disabled');
            $("#statement").val('');
            socket.emit('chat message', {mute: 1, postedby: postedby, entryuid: '', entrytext: $('#statement').val(), graph: ''});
        }

        return false;
    });

    $('#statement').keypress(function(e){

        // Submit the form on enter

        if(e.which == 13 && !e.shiftKey) {
            e.preventDefault();
            $('#submitbutton').trigger('click');
        }

    });

}

// Hide / Show Statements DIV

function toggle_statements() {

    /*$('#graph-link').toggleClass('graph-chat');
    $('#entries').toggleClass("hide-entries");
    $('#statements').toggleClass("hide-statements");

    if ($('#graph-link').hasClass('graph-chat')) {
        //$('#switcher-panel').toggleClass("hide-menu");
        $('#finds').trigger('click');
        $('#switcher-selector').toggleClass("hide-menu");
    }
    else {
        // $('#switcher-panel').toggleClass("hide-menu");
        $('#switcher-selector').toggleClass("hide-menu");
        if (pinnedNodes.length == 0) {
            $('#adds').trigger('click');
        }
    }*/

    $("#statements").fadeToggle();
    if (!$("#chat-link").hasClass('chat-highlight')) {
        localStorage.setItem('graph', 1);
    }
    else {
        localStorage.setItem('graph', 0);
    }
    $("#chat-link").toggleClass('chat-highlight');


}

function showStatements () {
        var isHidden_ = $("#statements").is(":hidden");
        if (isHidden_) {
            $('#statements').fadeIn();
            $("#chat-link").toggleClass('chat-highlight');
        }
}

function showEntries () {
        var isHidden_ = $("#entries").is(":hidden");
        if (isHidden_) {
            $('#entries').fadeIn();
        }
}


// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});

// Initialize JSON parser for SIGMA visualization

sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: 5,
                maxNodeSize: 16,
                minEdgeSize: 0.5,
                maxEdgeSize: 2,
                labelThreshold: 8
            }
        },
        function(sigma) {

            var i,
                    timeout = 4000,
                    nodes = sigma.graph.nodes(),
                    color_context = '#666',
                    color_addcontext = '#666688',
                    len = nodes.length;


            // This is a fix for JSON
            // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.
            // We also make the initial graph layout circular, so that ForceAtlas always looks the same

            var maxnodesize = 0;

            for (i = 0; i < len; i++) {
                var nodesize = 0;
                var angle = Math.PI * 2 * i / len;
                nodes[i].x = Math.cos(angle);
                nodes[i].y = Math.sin(angle);
                nodes[i].size = sigma.graph.degree(nodes[i].id);
                nodesize = nodes[i].size;
                if (maxnodesize < nodesize) maxnodesize = nodesize;
                nodes[i].color = color_context;
            }

            // We first need to save the original colors and LABELS of our
            // nodes and edges, like this:

            sigma.graph.edges().forEach(function(e) {

                var unique_edge_id = '';

                // Let's see if the edge source in alphabetical order is further than its target and change places

                if (e.source > e.target) {
                    unique_edge_id = e.target + '-' + e.source;
                }
                else {
                    unique_edge_id = e.source + '-' + e.target;
                }


                // Let's make a unique list of edges to count how many there are of the same kind

                if (edgesList[unique_edge_id]) {
                    ++edgesList[unique_edge_id];

                    // TODO this is a bit of a workaround - in the future could be better to distribute the weight evenly
                    e.size = e.weight + edgesList[unique_edge_id];
                }
                else {
                    edgesList[unique_edge_id] = 1;
                    e.size = e.weight;
                }


                e.originalColor = e.color;

                // Make an index of nodes to context
                if (contextNodeID[e.edge_context]) {
                    if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                        contextNodeID[e.edge_context].push(e.source);
                    if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                        contextNodeID[e.edge_context].push(e.target);
                }
                else {
                    contextNodeID[e.edge_context] = [];
                    contextNodeID[e.edge_context].push(e.source);
                    contextNodeID[e.edge_context].push(e.target);
                }

                // Make an index of nodes to statement
                if (nodesOfStatement[e.statement_id]) {
                    if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                        nodesOfStatement[e.statement_id].push(e.source);
                    if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                        nodesOfStatement[e.statement_id].push(e.target);
                }
                else {
                    nodesOfStatement[e.statement_id] = [];
                    nodesOfStatement[e.statement_id].push(e.source);
                    nodesOfStatement[e.statement_id].push(e.target);
                }

                if (statementsOfContext[e.edge_context]) {
                    if (statementsOfContext[e.edge_context].indexOf(e.statement_id) < 0)
                        statementsOfContext[e.edge_context].push(e.statement_id);
                }
                else {
                    statementsOfContext[e.edge_context] = [];
                    statementsOfContext[e.edge_context].push(e.statement_id);
                }

            });

            sigma.graph.nodes().forEach(function(n) {

                // Check if the node is in additional context and if yes, give it a different color
                if (addcontext) {
                    if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) > -1) {
                        n.color = color_addcontext;
                    }
                }



                // Save node's default color, for hide and show later
                n.originalColor = n.color;
                n.originalLabel = n.label;

                // Creating an index of node labels to IDs for filtering
                nodeIDs[n.label] = n.id;

                //console.log(n);

            });


            // Make a list of all the node labels displayed in the graph (for Autofill)

            nodeNames = _.keys(nodeIDs);



            // Get the context names - all the contexts that exist in the graph we just loaded
            contextNames = _.keys(contextNodeID);



            // Now we get the context IDs from the graph - a little bit of a workaround
            var suspects = [];
            var nonsuspects = [];

            sigma.graph.edges().forEach(function(e) {

                // If an edge has a context prefix, one of its nodes is a context, but we don't know which yet

                if (e.id.substr(0,7) == 'context') {
                        if (suspects.indexOf(e.source) < 0) {
                            suspects.push(e.source);
                        }

                        if (suspects.indexOf(e.target) < 0) {
                            suspects.push(e.target);
                        }

                }

                // If an edge doesn't have prefix context, for sure it has only nodes
                else {
                        if (nonsuspects.indexOf(e.source) < 0) {
                            nonsuspects.push(e.source);
                        }

                        if (nonsuspects.indexOf(e.target) < 0) {
                            nonsuspects.push(e.target);
                        }
                }



            });

            // Find the difference between two arrays above, so we get contexts only
            var contextids = _.difference(suspects, nonsuspects);


            // Now show those nodes that are contexts bigger and with a special label

            for (i = 0; i < len; i++) {

                if (contextids.indexOf(nodes[i].id) > -1) {
                    nodes[i].size = maxnodesize;
                    nodes[i].originalLabel = 'context: ' + nodes[i].originalLabel;
                    nodes[i].label = 'context: ' + nodes[i].label;
                }


            }


            // Put the contexts into the menu

            populateContextMenu(contextNames,nodeNames);


            if (document.getElementById('context').value) {
                current_context_field = [document.getElementById('context').value];
                $("#addedContexts").val(document.getElementById('context').value);
            }

            // if not, we're making the 'private' context default
            else {
                var lastcontexts = [];
                var laststatement = $(".entry:last").attr('data-uid');
                console.log(laststatement);
                for (var key in statementsOfContext) {
                    var reiteratestatements = statementsOfContext[key];
                    for (var i = 0; i< reiteratestatements.length; i++) {
                        if (laststatement == reiteratestatements[i]) {
                            lastcontexts.push(key);
                            console.log(key);
                        }
                    }

                }
                if (lastcontexts[0] == 'help' || !lastcontexts[0]) {
                    current_context_field = ['private'];
                    $("#addedContexts").val('private');
                }

                else {
                    current_context_field = lastcontexts;
                    $("#addedContexts").val(current_context_field.join());
                }
            }

            // let's now populate contextHandlers

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                },
                afterDelete: function(tag) {
                    console.log('initiated delete from sigma');
                    for (var i=current_context_field.length-1; i>=0; i--) {
                        if (current_context_field[i] === tag) {
                            current_context_field.splice(i, 1);
                        }
                    }
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                }
            });

            // Do ForceAtlasLayout

            sigma.startForceAtlas2();

            // Don't run it forever not to overheat :)

            setTimeout(function() {
                sigma.stopForceAtlas2();
            },timeout);

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.bind('clickNode', function(e) {

                // A node was clicked, so we assume there was a meaningful graph interaction
                graphInteraction = 1;

                var nodeLabel = e.data.node.originalLabel;


                if (nodeLabel.substr(0,9) == 'context: ') {
                    window.open('/' + current_user + '/' + nodeLabel.substr(9,nodeLabel.length) + '<% if (!perceivername) { %>/edit<% } %>',"_self");
                }
                else {

                    // Was the node clicked already? No? Add it to array of clicked nodes.
                    // Highlight the clicked node in the text.


                    if (splicedNodes.length > 1) {
                         pinnedNodes = [];
                         for (var p = 0; p < splicedNodes.length; p++ ){
                             pinnedNodes[p] = splicedNodes[p];
                         }
                    }
                    else if (splicedNodes.length == 1) {
                        pinnedNodes = [];
                        pinnedNodes[0] = splicedNodes[0];
                        splicedNodes = [];
                    }

                    if (pinnedNodes.indexOf(nodeLabel) < 0) {
                        pinnedNodes.push(nodeLabel);
                    }
                    else {
                        var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                        if (pinnedIndex > -1) {
                            pinnedNodes.splice(pinnedIndex,1);
                            $('.entry').fadeIn(400);
                        }

                    }

                    // console.log("node clicked, now will filter for nodes " + pinnedNodes);
                    socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});


                    // Now show / hide statements that have the search field

                    filter_statements(pinnedNodes);




                    // If the window is wide enough to show the menu AND div with statements is not visible

                    var isHidden = $("#statements").is(":hidden");

                    if (isHidden) {

                        var delayShow = 6000;

                        clearTimeout(inactiveTimeout);
                        inactiveTimeout = setTimeout(showStatements, delayShow);

                        $('#graph-container').unbind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop');
                        $('#graph-container').bind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop', function(){
                            if (graphInteraction) {
                                clearTimeout(inactiveTimeout);
                                inactiveTimeout = setTimeout(showStatements, delayShow);
                            }
                        });


                    }

                }

            });


            // Show node's label when we're over it

            sigma.bind('overNode', function(e) {
                e.data.node.label = e.data.node.originalLabel;
                sigma.refresh();
            });



            // Hide node's label when we're out of it

            sigma.bind('outNode', function(e) {
                if (e.data.node.color != e.data.node.originalColor && pinnedNodes.indexOf(e.data.node.originalLabel) < 0) {
                    e.data.node.label = '';
                }
                sigma.refresh();
            });

            // Zoom Graph Control

            var c = sigma.camera;


            $("#zoom-in").on('click', function(e) {
                // Zoom in - single frame :
                c.goTo({
                    ratio: c.ratio / c.settings('zoomingRatio')
                });
            });

            $("#zoom-out").on('click', function(e) {
                // Zoom out - single frame :
                c.goTo({
                    ratio: c.ratio * c.settings('zoomingRatio')
                });
            });

            $("#improve-layout").on('click', function(e) {

                sigma.startForceAtlas2();

                // Don't run it forever not to overheat :)

                setTimeout(function() {

                    sigma.stopForceAtlas2();
                }, 3000);

            });


            // Forward from the graph function

            $("#go_next").on('click', function(e) {

                var searchQuery = pinnedNodes.join("+");



                if (go_next_add) {
                    searchQuery = searchQuery + '+' + go_next_add;
                }

                if (searchQuery.length > 0 || go_next_add) {

                    if (go_next_override) {
                        if (pinnedNodes.length > go_next_override) {
                            window.open('http://google.com/search?q=' + searchQuery,'_blank');
                        }
                       else {
                            window.open(forwardTo + searchQuery,'_blank');
                        }
                    } else {
                        window.open(forwardTo + searchQuery,'_blank');
                    }
                }
                else {
                    alert("Click this after you select a few nodes to find them on the web.");
                }



            });



            // Here we perform some live updates of the graph on receiving a Socket.IO message
            // We could also move this code and use sigma.instances(0).graph.nodes() to get sigma properties

            // TODO set up chatroom, make better design, think of graph sharing functionality

            socket.on('chat message', function(msg){

                var posted_by = msg.postedby;

                var added_entry =  "<div class='entry' style='display: none;' data-uid='" + msg.entryuid + "'><p class='entry-text'>" + msg.entrytext + "</p><p class='entry-date'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

                if (!selfPosted) {

                    added_entry =  "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

                    if (msg.help) {
                        added_entry =  "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>help tip &nbsp;<em></em><a href='javascript:' class='disablehelp'>disable</a></em></p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";
                    }

                    // We will set a user for receiving. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
                    var receivedby = '';

                     <% if (perceivername) { %>
                        receivedby = '<%= perceivername %>';
                    <% } %>
                    // TODO make it possible that those statements get submitted in both graphs

                    // So the user who posted is not the same who's receiving? then submit the form. If the sender didnt have the mute option
                    if ((receivedby != msg.postedby) && !msg.mute) {


                        /*var temporary_statement = $('#statement').val();
                        $('#statement').val(msg.entrytext);
                        console.log($("#submitform").serialize());*/

                        var to_submit = $('#submitform').serializeArray();

                        for (key in to_submit) {
                            if (to_submit[key].name == 'entry[body]') {
                                to_submit[key].value = msg.entrytext;
                            }
                        }

                        $.post('/post', $.param(to_submit))
                                .done(function(res) {

                          /*          $('#statement').val(temporary_statement);*/

                                    //3. Receive the server response, no need to emit an event
                                    if (res.entryuid) {
                                        //4. Show the updated text
                                        console.log('submitted externally');
                                    }
                                    else if (res.errormsg) {
                                        alert(res.errormsg);
                                    }
                                    else {
                                        alert('Something went wrong, please, try again...');
                                    }
                                })
                                .fail(function(res) {
                                    alert("Server Error: " + res.status + " " + res.statusText);
                                });

                    }



                }
                else {
                    selfPosted = null;
                }

                $(added_entry).appendTo($('#entries')).slideDown("fast");
                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

                //$('#entries').append(added_entry).slideUp("fast");

                if ($(window).height() < 600) {
                    document.activeElement.blur();
                }


                    entryClick();
                    entryDoubleClick();

                    var addednodes = msg.graph.nodes;
                    var addededges = msg.graph.edges;



                    for (var i = 0; i < addednodes.length; i++) {

                        if (nodeNames.indexOf(addednodes[i].label) == -1) {

                           // var angle = Math.PI * 2 * i / len;

                            sigma.graph.addNode({
                                id: (id = addednodes[i].id),
                                label: addednodes[i].label,
                                originalLabel: addednodes[i].label,
                                originalColor: color_context,
                                size: maxnodesize - 2,
                                x: Math.random(),
                                y: Math.random(),
                                color: color_context
                            });
                            nodeNames.push(addednodes[i].label);


                        }
                    }

                    for (var j = 0; j < addededges.length; j++) {

                       if ((addededges[j].statement_id == msg.entryuid)) {

                            sigma.graph.addEdge({
                                id: addededges[j].id,
                                source: addededges[j].source,
                                target: addededges[j].target,
                                weight: addededges[j].weight,
                                size: addededges[j].weight,
                                statement_id: addededges[j].statement_id,
                                edge_context: addededges[j].edge_context
                            });

                        }

                    }

                    sigma.graph.nodes().forEach(function(n) {
                        if (n.id == 'dummy') {
                            sigma.graph.dropNode('dummy');
                        }
                        n.size = sigma.graph.degree(n.id);

                    });

                    // TODO this code duplicates from above - move into a function
                    sigma.graph.edges().forEach(function(e) {
                        // Make and index of nodes to statement
                        if (nodesOfStatement[e.statement_id]) {
                            if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                                nodesOfStatement[e.statement_id].push(e.source);
                            if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                                nodesOfStatement[e.statement_id].push(e.target);
                        }
                        else {
                            nodesOfStatement[e.statement_id] = [];
                            nodesOfStatement[e.statement_id].push(e.source);
                            nodesOfStatement[e.statement_id].push(e.target);
                        }

                        if (statementsOfContext[e.edge_context]) {
                            if (statementsOfContext[e.edge_context].indexOf(e.statement_id) < 0)
                                statementsOfContext[e.edge_context].push(e.statement_id);
                        }
                        else {
                            statementsOfContext[e.edge_context] = [];
                            statementsOfContext[e.edge_context].push(e.statement_id);
                        }
                    });

                    sigma.refresh();

                    sigma.startForceAtlas2();

                    // Don't run it forever not to overheat :)

                    setTimeout(function() {

                        sigma.stopForceAtlas2();

                    }, 3000);

                    //console.log(newnodes);
                    // console.log(msg.graph.edges);
                    // console.log(sigma.graph.edges());


            });


            socket.on('delete message', function(msg){


                $('[data-uid="' + msg.entryuid + '"]').fadeOut();

                $("#statement").val('');

                // When searched for nodes in that statement, nothing will appear.

                nodesOfStatement[msg.entryuid] = [];

                var nodesToKeep = [];

                sigma.graph.edges().forEach(function(e) {

                    // If a node appears in at least one statement, we add him in ToKeep list
                    if (nodesOfStatement[e.statement_id].indexOf(e.source) > -1) {
                        nodesToKeep.push(e.source);
                    }

                    if (nodesOfStatement[e.statement_id].indexOf(e.target) > -1) {
                        nodesToKeep.push(e.target);
                    }

                    var statePosition = statementsOfContext[e.edge_context].indexOf(e.statement_id);
                    if (statePosition < 0) {
                        statementsOfContext[e.edge_context].splice(statePosition, 1);
                    }


                });



                sigma.graph.nodes().forEach(function(n) {
                    if (nodesToKeep.indexOf(n.id) < 0) {
                        sigma.graph.dropNode(n.id);
                    }

                });

                sigma.refresh();

                sigma.startForceAtlas2();

                // Don't run it forever not to overheat :)

                setTimeout(function() {

                    sigma.stopForceAtlas2();

                }, 3000);

                //console.log(newnodes);
                // console.log(msg.graph.edges);
                // console.log(sigma.graph.edges());


            });




        }
);

   var visibleentries_original = '0';

// TODO: 1. Add search function by #hashtag; 2. Attach that same function to hashtag doubleclick;

// Auto-resize to fill content;

    $(document).ready(function(){

        $('.tooltip').tooltipster({
            theme: 'tooltipster-noir',
            position: 'left',
            maxWidth: 200,
            delay: 1000

        });

        var privacyform = '';

        var graph_share_url = hostsite + '/' + current_user;

        if (current_context) {
            graph_share_url = graph_share_url + "/" + current_context;
        }

        var privacy_iframe = "<iframe width='100%' height='500' style='height: 500px' src='http://" + graph_share_url + "?hide_always=1&link_hashtags=1' frameborder='0' allowfullscreen></iframe>";

        <% if (contextpublic && context && !perceivername && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This set can be viewed on:<br><input type="text" id="embedurl" size="25" maxlength="80" class="pure-input" value="http://' + graph_share_url + '"><br><br>Embed code for websites:<br><input type="text" id="embedcode" size="25" maxlength="100" class="pure-input" value="' + privacy_iframe + '"><br><br><input type="submit" id="privacybutton" name="privacy" value="make private"></form></span>')

        <% } else if (!perceivername && context && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This set is currently private and cannot be seen by the public.<br><br><input type="submit" id="privacybutton" name="privacy" value="make public"></form></span>')
        <% }  %>

        $('#privacy-link').tooltipster({
            theme: 'tooltipster-noir',
            position: 'top-right',
            maxWidth: 220,
            interactive: true,
            content: privacyform,
            functionReady: function() {
                $('#embedurl').focus(function(event) {
                    setTimeout(function() {$('#embedurl').select();}, 0);
                });
                $('#embedcode').focus(function(event) {
                    setTimeout(function() {$('#embedcode').select();}, 0);
                });
            }
        });


        collaborate_message = '<a href="mailto:chat@infranodus.com?subject=Chat%20Now&body=http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '">Invite us</a> or other people for a real-time constellaversation  just share the link below:<br>';

        collaborate_html = '<span><form class="pure-form">' + collaborate_message + '<input type="text" id="collaburl" size="22" maxlength="80" class="pure-input" value="http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '"></form></span>';

        collaborate_content = $(collaborate_html);

        $('#collaborate-link').tooltipster({
            theme: 'tooltipster-noir',
            position: 'top-right',
            maxWidth: 220,
            interactive: true,
            content: collaborate_content,
            functionReady: function() {
                $('#collaburl').focus(function(event) {
                    this.setSelectionRange(0, 9999);
                });
            }
        });







        <% if (!perceivername) { %>

            // Advertise graph collaboration module
            if (!collaborate_invite) {
                var collab_content = $('#collaborate-link').tooltipster('content');

                var graph_share_url = hostsite + '/' + current_user;

                if (current_context) {
                    graph_share_url = graph_share_url + "/" + current_context;
                }

                var collab_invite = '<a href="mailto:chat@infranodus.com?subject=Chat%20Now&body=http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '">Chat Now!</a><br>';

                var times_seen = localStorage.getItem('TooltipSeen');

                if (times_seen >= 1) {
                    localStorage.setItem('TooltipSeen', parseInt(times_seen) + 1);
                }
                else {
                    localStorage.setItem('TooltipSeen', 1);
                }

                if (times_seen < 4) {
                    $('#collaborate-link').tooltipster('content', $(collab_invite));
                    $('#collaborate-link').tooltipster('show');
                    setTimeout(function() {
                        $('#collaborate-link').tooltipster('hide');
                        setTimeout(function() {
                            $('#collaborate-link').tooltipster('content', collab_content);
                        }, 1000);
                    }, 2000);
                }
                else if (times_seen > 15) {
                    localStorage.setItem('TooltipSeen', 1);
                }
            }

        // START Speech Recognition Module only for Chrome

        if ('webkitSpeechRecognition' in window) {

            var recognition = new webkitSpeechRecognition();

            $('#microphone-link').fadeIn();

            if (localStorage.getItem('microphone') == 1) {
                $('#microphone-link').toggleClass('microphone-on', 'add');
                activateVoiceInput();
            }

            $("#microphone-link").click(function(e) {

                e.preventDefault();

                if (localStorage.getItem('microphone')  == 1) {
                    localStorage.setItem('microphone', 0);
                    $('#microphone-link').toggleClass('microphone-on', 'remove');
                    recognition.abort();
                }
                else {
                    localStorage.setItem('microphone', 1);
                    activateVoiceInput();
                    $('#microphone-link').toggleClass('microphone-on', 'add');
                }

            });

        }


            function activateVoiceInput() {



                    var voiceresult = '';

                    var previoustalk = '';

                    // Are we processing a short phrase or performing continuous dictation?
                    recognition.continuous = false;

                    // Do we require interim results in addition to the final results?
                    recognition.interimResults = true;

                    // We speak The US English here
                    recognition.lang = 'en-US';

                    if (language == 'en' || language == 'en-US') {
                        localStorage.setItem('language', 'en');
                    }

                    else if (language == 'ru' || language == 'russian') {
                        recognition.lang = 'ru';
                        localStorage.setItem('language', 'ru');
                    }

                    if (localStorage.getItem('language') == 'ru') {
                        recognition.lang = 'ru';
                        localStorage.setItem('language', 'ru');
                    }

                    // Kick off the Speech to Text recognition process
                    recognition.start();

                    // Set up
                    recognition.onstart = function(event){
                        console.log("onstart", event);
                    }
                    // Set up
                    recognition.onspeechstart = function(event){
                        console.log("onspeechstart", event);
                    }

                    // Process parsed result
                    recognition.onresult = function(event){
                        // console.log("onresult", event);
                        voiceresult = previoustalk + event.results[0][0].transcript;
                        $('#statement').val(voiceresult);
                        console.log(event.resultIndex);
                        for (var i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {
                                recognition.abort();
                                if (voiceresult.length > 4) {
                                    setTimeout(function(){
                                        $('#submitbutton').trigger('click');
                                    }, 1000);

                                }
                                else {
                                    previoustalk = voiceresult + ' ';
                                    // recognition.start();
                                }
                            }
                        }
                    }

                    // Handle error
                    recognition.onerror = function(event){
                        console.log("onerror", event);
                        if (event.error == 'no-speech') {

                        }
                    }

                  /*  // Housekeeping after success or failed parsing
                    recognition.onspeechend = function(){
                        console.log("onspeechend");
                        if (voiceresult.length > 4) {
                            setTimeout(function(){
                                $('#submitbutton').trigger('click');
                            }, 1000);

                        }
                        else {
                            previoustalk = voiceresult + '';
                            // recognition.start();
                        }

                    }*/


                    recognition.onend = function(){

                        console.log("onend");
                        if (localStorage.getItem('microphone') == 1) {
                            recognition.start();
                        }

                    }



            }


            // END Speech recognition module


         <% } %>



        $("#chat-link").click(function(e) {
            e.preventDefault();

            // The user clicked on the graph icon, so we reset his graph interaction activity for timeout later
            graphInteraction = null;
            clearTimeout(inactiveTimeout);

            toggle_statements();


        });

        $("#imports").click(function(e) {
            var fornode = '';
            if (pinnedNodes.length > 0) {
                 fornode = toTitleCase(pinnedNodes[pinnedNodes.length - 1].replace(/_/g, " "));
            }
            $(this).attr("href","/import?context=<%= context %>&fornode=" + fornode);
        });

        function toTitleCase(str)
        {
            return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
        }

        // Activate content switcher Set1 and set delay time for fade
        jcps.fader(0, '#switcher-panel', '.set1');



        $('#entries').css({height:  $(window).height() - $('#entryform').height() - 100});

        $(window).resize(function() {
            $('#entries').css({height:  $(window).height() - $('#entryform').height() - 100});
            $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
        });

        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);




        $('#switcher-selector').on('click', 'li', function() {


            $('#topmenuitems').each(function() {
                $("li", this).each(function(i) {
                    $(this).removeClass('pure-menu-selected-top');
                });
            });

            this.className = 'pure-menu-selected-top';


            var topmenuaction = $(this).children(":first").attr('id');

            // Repopulate context for addition field if it was the one clicked

            if (topmenuaction == 'adds') {

                current_context_field = [];

                // Are we inside some context already?

                if (document.getElementById('context').value) {
                    current_context_field.push(document.getElementById('context').value);
                    $("#addedContexts").val(document.getElementById('context').value);
                }

                // if not, we're making the 'private' context default
                else {
                    var lastcontexts = [];
                    var laststatement = $(".entry:last").attr('data-uid');
                    console.log(laststatement);
                    for (var key in statementsOfContext) {
                        var reiteratestatements = statementsOfContext[key];
                        for (var i = 0; i< reiteratestatements.length; i++) {
                            if (laststatement == reiteratestatements[i]) {
                                lastcontexts.push(key);
                                console.log(key);
                            }
                        }

                    }
                    if (lastcontexts[0] == 'help') {
                        current_context_field = ['private'];
                        $("#addedContexts").val('private');
                    }
                    else {
                        current_context_field = lastcontexts;
                        $("#addedContexts").val(current_context_field.join());
                    }
                }

                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in cancel field: ' + current_context_field.join());
                    }
                });

                submitFormProcess();


            }


            // Autocomplete for search input
            $("#search").autocomplete({
                source: nodeNames,
                minLength: 1,
                delay: 500,
                messages: {
                    noResults: '',
                    results: function() {}
                },
                select: function(event, ui) {

                    var filter = ui.item.value;



                }

            });

            search_graph();


        });

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {

                var filter = ui.item.value;



            }

        });

        search_graph();

        // Make texarea automatically resizeable
        $('textarea').autosize();

        visibleentries_original = $(".entry:visible").length;

        // Statement edit / delete functionality

        var filteringstarted = 0;



        entryClick();

        // If it's NOT some other user watching the graph, then statements can be edited. Otherwise - no.
        <% if (!perceivername) { %>
        entryDoubleClick();




        infraTalk();
        <% } %>


        // Highlight statement if clicked once






        // Deal with each date

        $(".entry-date").each(function() {
            var convertedTime = timeConverter($(this).text()) ;
            $(this).text(convertedTime);
        });


        function timeConverter(UNIX_timestamp){
            var modTimestamp = UNIX_timestamp.substr(0, UNIX_timestamp.length - 4);
            var time = moment(modTimestamp, 'x').fromNow();
            return time;
        }

        if (hide_always) {
            toggle_statements();
            //localStorage.setItem('graph', 1);
        }

        if (hide_when_small) {
            if ($('#menuLink').is(':visible')) {
                toggle_statements();
                //localStorage.setItem('graph', 1);
            }

        }


// Are we loading the page to only show the graph?

        <% if (background == '1' || background == 'graph') { %>
           // $('#finds').trigger('click');

            toggle_statements();
            //localStorage.setItem('graph', 1);
            graphOnly = 1;
        <% } %>

        if (localStorage.getItem('graph') == 1 && !graphOnly && !hide_always && !hide_when_small) {
            var isHidden__ = $("#statements").is(":hidden");
            if (!isHidden__) {
                $('#statements').fadeOut();
                $("#chat-link").toggleClass('chat-highlight','add');
            }
        }

        socket.on('node click', function(msg){

              pinnedNodes = msg.pinnedNodes;
              splicedNodes = msg.splicedNodes;
              var pinnedIndex = msg.pinnedIndex;

              // Are we clicking the node that was clicked already? Then show all divs
              if (pinnedIndex > -1) {
                    $('.entry').fadeIn(400);
              }

              // Filter statements and select nodes on the graph
              filter_statements(pinnedNodes);

        });


        });







    // Textarea select conversion to hashtags

    // For now it's disabled, but will be enabled for bulk statement correction later

    /*var getSelected = function(){
        var t = '';
        if(window.getSelection) {
            t = window.getSelection();
        } else if(document.getSelection) {
            t = document.getSelection();
        } else if(document.selection) {
            t = document.selection.createRange().text;
        }
        return t;
    }

    $("#statement").select(function(eventObject) {
        var selectedText = getSelected().toString();

        var statementReplace = $("#statement").val();

        if ((statementReplace.indexOf('@'+selectedText) === -1) && (selectedText !== statementReplace)) {

            var regex = RegExp(selectedText, "g");

            var dasherized = S(selectedText).dasherize().chompLeft('-').s;

            // TODO check words for morphology (if found, alert)

            var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
            $("#statement").val(replacedString);
        }

    });*/



    function entryClick () {

        $(".entry").on('click', function(e) {
            if (e.target.className == 'app-link-menu') {

                if ($(this).find('.app-link-menu').text() == 'hide filtered') {
                    $(this).find('.nonmatched-sentence').fadeOut(400);
                    $(this).find('.app-link-menu').text('show filtered');
                }
                else {
                    $(this).find('.nonmatched-sentence').fadeTo(400, '0.4');
                    $(this).find('.app-link-menu').text('hide filtered');
                }

            }


            // A parameter to check if we're taking off the flag

            var alreadyClicked = null;

            // Make all entries semitrasparent


            if (pinnedNodes.length == 0) {

                $(".entry").each(function() {
                    if ($(this).css('opacity') < 1) {
                        $(this).css('opacity', '1');
                        alreadyClicked = 1;
                    }
                    else {
                        $(this).css('opacity', '0.3');
                    }
                });

                // The one clicked is not transparent

                $(this).css('opacity','1');

            }



            var keepStatementID = e.currentTarget.dataset.uid;


            console.log(keepStatementID);

            // Make only those edges visible that belong to the statement selected

            if (!alreadyClicked && pinnedNodes.length == 0) {

                sigma.instances(0).graph.edges().forEach(function(e) {

                    if (e.statement_id == keepStatementID) {
                        e.color = e.originalColor;
                    }
                    else {
                        e.color = '#ddd';
                    }

                });

                // Make only those nodes visible that belong to the statement selected

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    // Is there no contexts at all? Show the node.
                    if (nodesOfStatement[keepStatementID].indexOf(n.id) < 0)  {
                        n.color = '#ddd';
                        n.label = '';
                    }
                    else {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    }
                });
            }
            else if (e.target.className == 'app-link-menu') {

                // Do nothing

            }
            else {

                if (pinnedNodes.length == 0) {
                    sigma.instances(0).graph.edges().forEach(function(e) {
                        e.color = e.originalColor;
                    });

                    // Make only those nodes visible that belong to the statement selected

                    sigma.instances(0).graph.nodes().forEach(function(n) {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    });
                }

            }

            sigma.instances(0).refresh();
        });

    }


    function entryDoubleClick() {

        $(".entry").on('doubletap', function(e) {

        e.preventDefault();

        // Get the content from the form edit and copy it into the switcher panel to show to the user

        var _formcontent = $('#adds-content').html();

        $("#switcher-panel").html(_formcontent);

        // Get the statement into the edit box at the top
        $("#statement").val($('.entry-text', e.currentTarget).text());

        // Retrieve that statement's ID into the hidden field (for edit or delete)
        $('input[name="statementid"]').val(e.currentTarget.dataset.uid);

        // Retrieve the date of the statement
        $('input[name="timestamp"]').val(e.currentTarget.dataset.timestamp);

        $('#topmenuitems').each(function() {
            $("li", this).each(function(i) {

                $(this).removeClass('pure-menu-selected-top');

            });
        });




        // Change / add buttons
        $('#submitbutton').hide();

        if (!$('#deletebutton').val()) {

            $("#submitform").append('<input type="submit" name="edit" value="edit" id="editbutton" class="pure-button"> <input type="submit" style="margin: 0px 8px;" name="delete" value="delete" id="deletebutton" > <input type="submit" name="cancel" value="cancel" id="cancelbutton" class="pure-button">');

            $('#deletecontextbutton').hide();
            $('#privacy-link').hide();
            $('#collaborate-link').hide();


            // Delete text from the form in case of Cancel, remove the buttons

            $("#cancelbutton").on('click', function(e) {

                e.preventDefault();

                $("#statement").val('');
                $('#editbutton').remove();
                $('#deletebutton').remove();
                $('#cancelbutton').remove();
                $('#submitbutton').show();
                $('#deletecontextbutton').show();
                $('#privacy-link').show();
                $('#collaborate-link').show();

                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

                $('input[name="timestamp"]').val('');

                // Populate contexts list next to statement add

                current_context_field = [];

                // Are we inside some context already?

                if ($("#context").val()) {
                    current_context_field.push($("#context").val());
                    $("#addedContexts").val($("#context").val());
                }

                else {

                    if (document.getElementById('context').value) {
                        current_context_field.push(document.getElementById('context').value);
                        $("#addedContexts").val(document.getElementById('context').value);
                    }

                    // if not, we're making the 'private' context default
                    else {
                        var lastcontexts = [];
                        var laststatement = $(".entry:last").attr('data-uid');
                        console.log(laststatement);
                        for (var key in statementsOfContext) {
                            var reiteratestatements = statementsOfContext[key];
                            for (var i = 0; i< reiteratestatements.length; i++) {
                                if (laststatement == reiteratestatements[i]) {
                                    lastcontexts.push(key);
                                    console.log(key);
                                }
                            }

                        }
                        if (lastcontexts[0] == 'help') {
                            current_context_field = ['private'];
                            $("#addedContexts").val('private');
                        }
                        else {
                            current_context_field = lastcontexts;
                            $("#addedContexts").val(current_context_field.join());
                        }
                    }


                }



                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in cancel field: ' + current_context_field.join());
                    }
                });

                // TODO a better way of dealing with delete and edit - in the logic of everything else

                submitFormProcess();




            });

            $("#deletebutton").on('click', function(e) {
                e.preventDefault();

                $('#statement').addClass('loading');

                $('#deletebutton').attr('disabled', 'disabled');

                $('input[name="timestamp"]').val('');


                var formSubmit = $("#submitform").serialize() + '&delete=delete';

                $.post('/post', formSubmit)
                        .done(function(res) {
                            //3. Receive the server response, no need to emit an event
                            console.log(res);
                            if (res.successmsg) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $('#statement').removeClass('loading');
                                $('#deletebutton').removeAttr('disabled');
                                socket.emit('delete message', {entryuid: res.statementid});
                                $("#warnings").append('<p class="warning">The statement was deleted.</p>');
                                $("#warnings").slideDown('slow');
                                $('#cancelbutton').trigger('click');
                                setTimeout(function() {
                                    $("#warnings").slideUp('slow');
                                    $("#warnings").text('');
                                },2000);


                            }
                            else if (res.errormsg) {
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function(res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });



            });

            $("#editbutton").on('click', function(e) {
                e.preventDefault();

                $('#statement').addClass('loading');

                $('#editbutton').attr('disabled', 'disabled');

                var statementToHide = $('#statementid').val();

                $('[data-uid="' + statementToHide + '"]').slideUp();

                var formSubmit = $("#submitform").serialize() + '&edit=edit';

                $.post('/post', formSubmit)
                        .done(function(res) {
                            //3. Receive the server response, no need to emit an event
                            if (res.entryuid) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $('#statement').removeClass('loading');
                                $('#editbutton').removeAttr('disabled');
                                $('#cancelbutton').trigger('click');
                                socket.emit('chat message', {entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                            }
                            else if (res.errormsg) {
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function(res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });



            });



        }


        current_context_field = [];

        for (var key in statementsOfContext) {
            var checkstatements = statementsOfContext[key];
            for (var l = 0; l<checkstatements.length; l++) {
                if (checkstatements[l] == e.currentTarget.dataset.uid) {
                    current_context_field.push(key);
                }
            }

        }

        console.log('context of statement clicked: ' + current_context_field);

        // Which contexts the statement should be in?
        $("#addedContexts").val(current_context_field.join());

        // Update the contexts list if anything changes in the context settings of the statement

        $("#addToContexts").tagHandler({
            assignedTags: current_context_field,
            availableTags: contextNames,
            autocomplete: true,
            afterAdd: function(tag) {
                current_context_field.push(tag);
                $("#addedContexts").val(current_context_field.join());
                console.log('contexts in statement field: ' + current_context_field.join());
            }
        });


        // Smoothly scroll up
        $("html, body").animate({ scrollTop: 0 }, "slow");


        // THIS WAS BEFORE WHEN YOU CLICK A STATEMENT ONCE

        // Shall all statements inside Entry if clicked




    });
    }

    // Initial conversation with the user - HELP of a sorts

    function infraTalk (timer) {
        if (localStorage.getItem('disablehelp') != 1) {
        if (!timer) {
            var timer = 3000;
        }
        var utterance = '';
        var vocabulary = [];

        if (!current_context) {
            vocabulary = [
                "Let's start from a clear page... What are you interested in thinking about?",
                "Can you say something else about it?"
            ];
        }
        else {
            vocabulary = [
                "To start, write your ideas, import data, or invite somebody to collaborate using the icon below..."
            ];
            timer = 10000;
        }

        var visibleentries_current = $(".entry:visible").length;

        if (!visibleentries_current || visibleentries_current == null) {
            visibleentries_current = 0;
        }
        var pose = visibleentries_current;
        utterance = vocabulary[pose];
        if (utterance) {
            setTimeout(function() {
                socket.emit('chat message', {mute: 1, postedby: 'infratalk', entryuid: '', entrytext: utterance, graph: '', help: 1});
            }, timer);
        }
        }

    }


    // Filter out the statements that don't have any of the nodes clicked

    var timesfiltered = 0;


    function filter_statements(pinnedNodes, origin) {


        var showingsomething = 0;

        var visibleentries = visibleentries_original;

        // Hide the sentences that don't contain the terms

        $(".entry").each(function(){

            var currentDiv = $(this).attr('data-uid');

            // Retrieve the statement text from the entry, clean from html
            var originaltext = $(this).children('.entry-text').html();

            // Make an array from sentences of that text
            var sentences = originaltext.split(/[.|!|?]\s/gi);

            var searchlemmas = [];


            // START Check what sentences contain the node clicked

            var startmark = sentences.length; // How many sentences are inside

            for (var i = 0; i < sentences.length; i++) {

                // What language is the sentence?
                var sentence_cyrillic = sentences[i].match(/[--]/);

                var nodesfound = 0;

                // Transform the sentence into a series of morphemes
                var sentences_lemmas = sentences[i].split(' ');

                // SEARCH MOD
                /*for (var z = 0; z < sentences_lemmas.length; z++) {
                    sentences_lemmas[z] = window.jstemmer(sentences_lemmas[z]);
                }
*/

                var sentences_lemmas_string = sentences_lemmas.join(' ');

                // Check how many of the nodes are found in This 1 Sentence i

                for (var j = 0; j < pinnedNodes.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = pinnedNodes[j].match(/[--]/);

                    // SEARCHMOD
                    // var search_lemma = window.jstemmer(pinnedNodes[j]);

                    var search_lemma = pinnedNodes[j];

                    searchlemmas.push(search_lemma);

                    if (sentences_lemmas_string.toLowerCase().indexOf(search_lemma.toLowerCase()) > -1) {
                        nodesfound = nodesfound + 1;
                    }
                    else if (sentence_cyrillic != null && search_cyrillic != null)  {
                        if (sentences_lemmas_string.toLowerCase().indexOf(search_lemma.toLowerCase().slice(0,-1)) > -1) {
                            nodesfound = nodesfound + 1;
                        }
                    }

                }

                // At least one node not found? Mark it as non matched

                if (nodesfound >= pinnedNodes.length) {
                    sentences[i] = sentences[i] + '.';
                }
                else {
                    sentences[i] = '<div class="nonmatched-sentence">' + sentences[i] + '.</div>';
                    startmark = startmark - 1;
                }


            }

            // Make a new text from the filtered sentences
            var newtext = '';

            if (startmark == sentences.length) {
                newtext = originaltext;
                // $(this).find('.entry-menu').fadeOut(500);
                showingsomething = showingsomething + 1;
            }

            else {
                newtext = originaltext; // sentences.join(' '); if we want to hide non-matched sentences
                // $(this).find('.entry-menu').fadeIn(500);
                if (startmark != 0) {
                    showingsomething = showingsomething + 1;
                }
            }

            if (startmark == 0) {

                $(this).fadeOut(500);

                visibleentries = visibleentries - 1;

                if (visibleentries == 0 && showingsomething == 0) {

                    $('.entry').fadeIn(500);

                    timesfiltered = timesfiltered + 1;

                    // This is if we want to remove the node before the last one.
                    // var posnodes = pinnedNodes.length - timesfiltered - 1;

                    var posnodes = 0;
                    var lastnode = pinnedNodes.length - 1;

                    // Final nodes to search

                    splicedNodes = [];


                    // First all of them

                    for (var k = 0; k < pinnedNodes.length; k++) {
                        splicedNodes[k] = pinnedNodes[k];
                    }

                    // Remove the one we can't find (the very first one of the bunch)

                    splicedNodes.splice(posnodes, 1);

                    // Save that one also into the list of the nodes we removed

                    notfoundNodes.push(pinnedNodes[posnodes]);

                    // This is for alert
                    // var r = confirm('No link between ' + pinnedNodes + '.\nShow entries just with ' + splicedNodes + '?');

                    // This is for plain message
                    // $('#messages').html('No entries contain "' + pinnedNodes.join(' and ') + '".<br>Showing entries that contain "' + splicedNodes.join(' and ') + '" only:<br>&nbsp;');

                    // Get the pinnedNodes back to a good shape
                    pinnedNodes = [];
                    for (var l = 0; l < splicedNodes.length; l++) {
                        pinnedNodes[l] = splicedNodes[l];
                    }

                    // Relaunch the function with the newly cleared list of pinnedNodes

                    filter_statements(pinnedNodes);

                }

            }
            else {

                // Populate statement with a new text

                $(this).children('.entry-text').html(newtext);

                // $(this).find('.nonmatched-sentence').fadeOut(500); this is only if we want to fade non-matched sentences - see above also


                // Show tags that are currently used in search

                var htmlNodes = '<ul class="tags">';

                for (var x = 0; x < notfoundNodes.length; x++) {
                    htmlNodes = htmlNodes + '<li><a class="notfound" href="#">' + notfoundNodes[x] + '</a></li>';
                }

                for (var q = 0; q < pinnedNodes.length; q++) {
                    htmlNodes = htmlNodes + '<li><a href="#">' + pinnedNodes[q] + '</a></li>';
                }


                htmlNodes = htmlNodes + '<div class="tagsend"></div></ul>';

                notfoundNodes = [];

                $('#messages').html(htmlNodes);



            }


        });

        // Highlight the nodes that were clicked

        $(".entry").removeHighlight();

        for (var i=0; i<pinnedNodes.length; i++) {
            $(".entry").highlight(pinnedNodes[i]);

        }

        // Show only the clicked nodes and their neighbors in the graph

        filter_graph(pinnedNodes, origin);

        // Add triggers to newly shown Tags elements

        addTagTriggers();

    }

    function addContextTriggers() {

    // TODO Add case for clicking viewAll, so it doesn't reload the page, but simply removes all filters

    // Find @Contexts and make them filter statements when clicked

        var contextsToFilter = [];


        $(".app-context-link").click(function(e) {
            e.preventDefault();
            var that = this;
            setTimeout(function() {
                var dblclick = parseInt($(that).data('double'), 10);
                if (dblclick > 0) {
                    $(that).data('double', dblclick-1);
                } else {
                    singleClick.call(that, e);
                }
            }, 300);
        }).dblclick(function(e) {
                    $(this).data('double', 2);
                    doubleClick.call(this, e);
                });


        // If double click on the menu, open it

        function singleClick (e) {

            window.location = e.target.href;

        }

        // If double click on a link, open it

        $(".app-url-link").on('click tap', function(e) {

              e.stopPropagation();

        });



        // If only one click, filter it

        function doubleClick (e) {

                var triggeredFromStatement = null;

                var addFilter = null;

                var removeFilter = null;

                // Extract filter label
                var filter = $(e.target).text();

                // Remove the first @ in case it's @mentions clicked from the statements
                if (filter.charAt(0) == '@') {
                    filter = filter.substr(1);
                    triggeredFromStatement = 1;
                }

                // Some tricks to make context switch from statements emulate menu items behavior
                if (triggeredFromStatement) {

                    // If the context is clicked inside the statement, we're just dealing with that event, not others
                    e.stopPropagation();

                    $(".menu-item-divided").each(function() {
                         if (S($(this).html()).stripTags().s == filter) {
                             if ($(this).hasClass('pure-menu-selected')) {
                                 $(this).removeClass('pure-menu-selected');
                                 removeFilter = 1;
                             }
                             else {
                                 $(this).addClass('pure-menu-selected');
                                 addFilter = 1;
                             }
                         }

                    });
                }

                // Index of that filter in our current contextsToFilter array
                var filterIndex = contextsToFilter.indexOf(filter);

                // Toggle menu highlights
                if ($(this).hasClass('pure-menu-selected') || removeFilter) {


                    // The context is to be removed
                    if (!removeFilter) {
                        $(this).removeClass('pure-menu-selected');
                    }

                    // Does it exist in the list of contexts to filter?
                    if (filterIndex > -1) {
                        contextsToFilter.splice(filterIndex, 1);
                    }

                    //TODO WTF is that?
                  /*  // Let's remove the nodes that belong to the removed context from the contextNodes
                    contextNodeID[to_remove_clean].forEach(function(element){
                        var index = $.inArray(element, contextNodes);
                        if (index>=0) contextNodes.splice(index, 1);
                    });*/


                     // Create context query for jQuery
                    var contextstring = '';

                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@"+contextsToFilter[0]+"')";

                        for (var l=1;l<contextsToFilter.length;++l) {
                            contextstring += ", .entry:contains('@"+contextsToFilter[l]+"')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if (contextsToFilter.length < 1 && !$('#listall').hasClass('pure-menu-selected') && !(current_context)) {
                        $('#listall').addClass('pure-menu-selected');
                    }

                }
                else {
                    if (!addFilter) {
                        $(this).addClass('pure-menu-selected');
                    }

                    // Add this context to a list of contextToFilter
                    if (filterIndex < 0) {
                        contextsToFilter.push(filter);
                    }

                    // Show only those that have the context

                    var contextstring = '';
                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@"+contextsToFilter[0]+"')";

                        for (var l=1;l<contextsToFilter.length;++l) {
                            contextstring += ", .entry:contains('@"+contextsToFilter[l]+"')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if ($('#listall').hasClass('pure-menu-selected')) {
                        $('#listall').removeClass('pure-menu-selected');
                    }


                }

                console.log(contextsToFilter);

                // Add contexts into the submission form
                document.getElementById('selectedContexts').value = contextsToFilter.join(',');

                console.log(document.getElementById('selectedContexts').value);

                // Add some remove @context functionality
                renderGraph(contextsToFilter);

         }

    }





    // Remove context filters function - launched only when a context is clicked

    function renderGraph(contextsToFilter) {

        // Creating the context index
        var nodesToKeep = [];

        var keepNodes = [];

        var keepEdges = [];

        // First, let's reiterate the graph and make a list of nodes and edges to keep

        if (contextsToFilter.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // Reiterating through edges, leaving only the nodes that appear in at least one filtered context

                contextsToFilter.forEach(function(element){

                    if (contextNodeID[element].indexOf(e.source) > -1) {
                        keepNodes.push(e.source);
                    }

                    if (contextNodeID[element].indexOf(e.target) > -1) {
                        keepNodes.push(e.target);
                    }

                });

                // Keep edges that are in at least one of the filtered contexts

                if (contextsToFilter.indexOf(e.edge_context) > -1) {
                    keepEdges.push(e.id);
                }


            });
        }

        // Uniqualize to avoid duplicates

        keepNodes = $.unique(keepNodes);
        keepEdges = $.unique(keepEdges);

        // Then let's reiterate the graph edges and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (contextsToFilter.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (keepEdges.indexOf(e.id) > -1) {
                // The edge is in the list to keep => show it normal color
                e.color = e.originalColor;

                // The source of the edge is in the list to keep, so we will keep it.
                if (keepNodes.indexOf(e.source) > -1) {
                    nodesToKeep.push(e.source);
                }
                // The target of the edge is in the list to keep, so we will keep it also.
                if (keepNodes.indexOf(e.target) > -1) {
                    nodesToKeep.push(e.target);
                }
                // PS We only do this check for the nodes that belong to the edges that we keep
            }
            else {
                // Otherwise (the edge IS in the list for removal), so we color the edge invisible
                e.color = '#ddd';
            }



        });



        // Ensure no duplicates
        nodesToKeep = $.unique(nodesToKeep);

        // Now that we know which nodes to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (contextsToFilter.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            // The node is not in the list to keep? Hide it!
            else if (nodesToKeep.indexOf(n.id) < 0)  {
                n.color = '#ddd';
                n.label = '';
            }

            // Looks like there is a filtering context function AND the node is in the keep list, so make it show!
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Refresh the graph (we do it through instances(0) as we're a bit outside of Sigma now)
        sigma.instances(0).refresh();


    }


    // Populate context menu

    function populateContextMenu (contextNames,nodeNames) {

        var switch_field = '';

        var context_filters = '';

        var currentContextURL = '';

        <% if (perceivername) { %>

            currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>">all sets</a></li>';

        <% } else { %>

            currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/edit">all sets</a></li>';

        <% } %>

        var addNewContext = '';

        var auxLinks = '';

        // The graph exists already?
        if (typeof contextNames[0] !== 'undefined' && contextNames[0] !== null) {
            contextNames.forEach(function(n) {
                if (n == current_context) {
                    // for the menu
                    <% if (perceivername) { %>
                        context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>/' + n + '">' + n + '</a></li>';
                        currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= perceivername %>">all sets</a></li>';
                    <% } else { %>
                        context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/' + n + '/edit">' + n + '</a></li>';
                        currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= user.name %>/edit">all sets</a></li>';
                    <% } %>

                }
                else {
                    // for the menu
                    <% if (perceivername) { %>
                        context_filters += '<li class="app-context-link menu-item-divided "><a href="/<%= perceivername %>/' + n + '">' + n + '</a></li>';
                    <% } else { %>
                        context_filters += '<li class="app-context-link menu-item-divided "><a href="/<%= user.name %>/' + n + '/edit">' + n + '</a></li>';

                    <% } %>

                    // for the statement add
                }
            });
        }
        // No graph, so show private
        else {
            context_filters += '<li class="app-context-link menu-item-divided"><a href="/<%= perceivername %>/private/edit">private</a></li>';
        }

        <% if (!perceivername) { %>
            addNewContext = '<li id="addNewContext" class="menu-item-divided"><a id="addcontextbutton" href="javascript:">+</a>&nbsp;<form action="/post" method="GET" class="pure-form" id="addcontextinput"><input type="text" id="addcontextname" size="7" class="pure-input"></form></li><li class="menu-item-divided">&nbsp;<a href="javascript:"></a></li>';
        <% } else { %>
            addNewContext = '<li class="menu-item-divided">&nbsp;<a href="javascript:"></a></li>';

        <% } %>


        // We are viewing the user's public page?

        <% if ((perceivername)) { %>

            // So we know whose statements we see, but is it the same as the user who's viewing them?
            <% if (perceivername == receivername) { %>

            <% if (context) { %>
                switch_field = '<li class="menu-item-small"><a href="/<%= perceivername %>/<%= context %>/edit">go to private view</a></li>';
            <% } else { %>
                switch_field = '<li class="menu-item-small"><a href="/<%= perceivername %>/edit">go to private view</a></li>';
            <% } %>

            // So we know whose statements we're going to view, but the user is not the same as the one who made them.
            <% } else { %>



            <% } %>

        // We are viewing the user's private page

        <% } else {  %>

        <% if (context) { %>

                switch_field = '<li class="menu-item-small"><a href="/<%= user.name %>/<% context %>">go to public view</a></li>';

            <% } else { %>

                switch_field = '<li class="menu-item-small"><a href="/<%= user.name %>">go to public view</a></li>';

            <% } %>


        <% } %>


        <% if (perceivername) { %>

            <% if (perceivername == receivername) { %>

                auxLinks = '<br>' +
                        '<li class="menu-item-small"><a href="/<%= perceivername %>/edit">back to private view</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="/logout">logout</a></li>' +
                        '<li class="menu-item-small"><a href="/settings">settings</a></li>' +
                        '<li class="menu-item-small"><a href="/import">import</a></li>' +
                        '<li class="menu-item-small"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';


            <% } else if (receivername) { %>

                auxLinks = '<br>' +
                        '<li class="menu-item-small"><a href="/<%= receivername %>/edit">back to <%= receivername %></a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="/">home page</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="/settings">settings</a></li>' +
                        '<li class="menu-item-small"><a href="/import">import</a></li>' +
                        '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';


            <% } else { %>

                auxLinks = '<br>' +
                        '<li class="menu-item-small"><a href="/">home page</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="/login">login</a></li>' +
                        '<li class="menu-item-small"><a href="/signup">signup</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="/#features">demo</a></li>' +
                        '<li class="menu-item-small"><a href="/#usecases">case studies</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

            <% } %>

        <% } else { %>

            auxLinks = '<br>' +
                    '<li class="menu-item-small"><a href="/logout">logout</a></li>' +
                    '<li class="menu-item-small"><a href="/settings">settings</a></li>' +
                    '<li class="menu-item-small"><a href="/import">import</a></li>' +
                    '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/cases/infranodus-the-network-thinking-app/" target="_blank">demo</a></li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/tag/infranodus/" target="_blank">case studies</a></li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                    '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

        <% } %>

        document.getElementById('contexts').innerHTML = switch_field +
                                                        currentContextURL +
                                                        context_filters +
                                                        addNewContext +
                                                        auxLinks;



        // Select range in textarea function

        $.fn.selectRange = function(start, end) {
            return this.each(function() {
                if (this.setSelectionRange) {
                    this.focus();
                    this.setSelectionRange(start, end);
                } else if (this.createTextRange) {
                    var range = this.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', start);
                    range.select();
                }
            });
        };

        // When add new context is clicked, add it into textarea and select it

        $("#addNewContext").on('tap', function(e) {

            $("#addcontextinput").css("visibility", "visible");
            $("#addcontextname").focus();


        });

        <% if (!perceivername) { %>
        $('#addcontextinput').submit(function(e) {
            e.preventDefault(); // to stop the form from submitting
            if ($('#addcontextname').val().length > 0) {
                var contextredirect = $('#addcontextname').val();
                contextredirect = contextredirect.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g,"");
                contextredirect = contextredirect.replace(/[^\w]/gi, '');
                window.location.href = "/<%= user.name %>/" + contextredirect + '/edit';
            }

        });
        <% } %>

        // Now time to trigger the actions we want to have when user clicks on the contexts
        addContextTriggers();

        // Initialize autofill for hashtags and contexts
        autofill(nodeNames,contextNames);




    }

    function search_graph() {

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {

                var filter = ui.item.value;



            }

        });

        $("#searchform").submit(function(event) {

            event.preventDefault();

            // What are we searching?
            var searchPhrase = $('#search').val();

            if (searchPhrase.length > 1) {

                // Clean up the search string
                searchPhrase = searchPhrase.replace(/\s+/g,' ').trim();

                // Separate terms into array
                var searchArray = searchPhrase.toLowerCase().split(" ");

                var searchPhraseLemmas = [];


                for (var j = 0; j < searchArray.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = searchArray[j].match(/[--]/);

                    // SEARCHMOD
                    // var search_lemma = window.jstemmer(searchArray[j]);

                    var search_lemma = searchArray[j];

                    searchPhraseLemmas.push(search_lemma);

                }

                for (var k = 0; k < searchPhraseLemmas.length; k++) {
                    if (pinnedNodes.indexOf(searchPhraseLemmas[k]) < 0) {
                        pinnedNodes.push(searchPhraseLemmas[k]);
                    }
                }

                filter_statements(pinnedNodes, "search");

            }


        });
    }


    function filter_graph(pins, origin){


            var toKeep = [];

            var toKeepMap = [];


            // Debug: show which nodes are clicked

            console.log(pins);

            // Are any nodes at all selected on the graph?

            if (pins.length > 0) {


                // Reiterate for each pinned node

                for (var i = 0; i < pins.length; i ++) {

                    // Now we reiterate through every node in the graph

                    sigma.instances(0).graph.nodes().filter(function(n) {

                        var pinSearch = '';

                        // Lemmataze search query if we're coming from search box

                        // SEARCHMOD
                       /* if (origin == 'search') {

                            var nodeLemma = window.jstemmer(n.originalLabel);


                            if (nodeLemma.length > 0) {
                                pinSearch = nodeLemma;
                            }
                            else {
                                pinSearch = n.originalLabel;
                            }
                        }

                        // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                        else {
                            pinSearch = n.originalLabel;
                        }*/

                        pinSearch = n.originalLabel;

                        // Is the current node of the graph one of the ones that was clicked before?

                        if (pins[i] == pinSearch) {



                            // The ID of the current node is...
                            var nodeId = n.id;

                            // Its neighbors are...
                            var nnodes = sigma.instances(0).graph.neighbors(nodeId);

                            var nnodesArray = []

                            // We create an array from neighbors that looks like toKeep one

                            for (key in nnodes) {
                                nnodesArray.push(nnodes[key]);
                            }

                            // If that's not the first iteration, we only keep intersection of both

                            if (i > 0) {
                                toKeep = _.intersection(toKeep, nnodesArray);
                            }
                            else {
                                toKeep = nnodesArray;
                            }

                            // add the node itself to keep
                            toKeep.push(n);



                        }

                    });

                }

                // Make array of nodes to keep unique to avoid duplicates

                toKeep = _.uniq(toKeep);

                console.log(toKeep);

                // Now convert this to an array that will be understood by the functions below

                for (key in toKeep) {
                    toKeepMap[toKeep[key].id] = toKeep[key];
                }


                // For each node in the graph

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    if (toKeepMap[n.id])  {

                        var pinSearch = '';

                        // Lemmataze search query if we're coming from search box
                        // SEARCHMOD
                       /* if (origin == 'search') {
                            var nodeLemma = window.jstemmer(n.originalLabel);


                            if (nodeLemma.length > 0) {
                                pinSearch = nodeLemma;
                            }
                            else {
                                pinSearch = n.originalLabel;
                            }
                        }

                        // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                        else {
                            pinSearch = n.originalLabel;
                        }*/

                        pinSearch = n.originalLabel;


                        if (pins.indexOf(pinSearch) > -1) {
                                n.color = '#0089e0';

                            }
                            else {
                                n.color = n.originalColor;

                            }
                            n.label = n.originalLabel;

                    }
                        else  {
                            n.color = '#ddd';
                            n.label = '';
                        }
                });

                sigma.instances(0).graph.edges().forEach(function(e) {
                        if (toKeepMap[e.source] && toKeepMap[e.target]) {
                            e.color = e.originalColor;
                        }
                        else {
                            e.color = '#ddd';
                        }
                });



            }

            // No nodes are selected (or all are deselected) - show the whole graph

            else {

                sigma.instances(0).graph.nodes().forEach(function(n) {


                   n.color = n.originalColor;
                   n.label = n.originalLabel;


                });

                sigma.instances(0).graph.edges().forEach(function(e) {

                   e.color = e.originalColor;

                });


                // We show the whole graph above so scroll down to all the statements
                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);


            }

            // Since the data has been modified, we need to
            // call the refresh method to make the colors
            // update effective.

            sigma.instances(0).refresh();


    }

    // Autofill initialized only after Sigma above loaded and populated all the nodes

    function autofill(nodeNames,contextNames) {

        // console.log(nodeNames);

        $('#statement').textcomplete([
            { // hashtags-concepts
                words: nodeNames,
                match: /\B#(\w*)$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {

                    return '#' + word + ' ';

                }
            },
            { // html
                mentions: contextNames,
                match: /\B@(\w*)$/,
                search: function (term, callback) {
                    callback($.map(this.mentions, function (mention) {
                        return mention.indexOf(term) === 0 ? mention : null;
                    }));
                },
                index: 1,
                replace: function (mention) {
                    return '@' + mention + ' ';
                }
            },
            { // hashtags-concepts
                words: nodeNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {

                        return word + ' ';

                }
            }

        ]);





        $('#addcontext').textcomplete([
            { // html
                mentions: contextNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.mentions, function (mention) {
                        return mention.indexOf(term) === 0 ? mention : null;
                    }));
                },
                index: 1,
                replace: function (mention) {
                    window.open("?addcontext=" + mention, "_self");
                    return '@' + mention + '';
                }
            }
        ]);
    }

    function addTagTriggers() {


        $(".tags").on('click', function(e) {

            e.preventDefault();

            var remove_node = e.target.innerText;

            var pinnedIndex = pinnedNodes.indexOf(remove_node);



            if (pinnedIndex > -1) {

                    pinnedNodes.splice(pinnedIndex,1);

                    notfoundNodes.push(remove_node);

            }

            if (splicedNodes.length > 1) {
                pinnedNodes = [];
                for (var p = 0; p < splicedNodes.length; p++ ){
                    pinnedNodes[p] = splicedNodes[p];
                }
            }
            else if (splicedNodes.length == 1) {
                pinnedNodes = [];
                pinnedNodes[0] = splicedNodes[0];
                splicedNodes = [];
            }

            // console.log("node clicked, now will filter for nodes " + pinnedNodes);

            $('.entry').fadeIn(400);

            filter_statements(pinnedNodes);



        });

    }

   // Replace hashtags function

    function replaceHashtags(hash){
        var replacementString = $.trim(hash);
        return ' <a href="' + forwardTo + replacementString.substr(1) +'" class="app-concept-link" target="_blank">' + replacementString + '</a>';
    }


    var hashRegex = /(?:\s|^)(?:#(?!\d+(?:\s|$)))(\w+)(?=\s|$)/gi;

    if (link_hashtags) {
        $(".entry").each(function() {
            // Retrieve the statement text from the entry, clean from html
            var originale = $(this).children('.entry-text').html();
            // Replace with hashtags
            $(this).children('.entry-text').html(originale.replace(/#(\w+)/g,  " <a href='" + forwardTo + "$1' class='app-concept-link' target='_blank'>$&</a>"));

        });
    }


    // LiveChat functionality

    if (window.addEventListener) {
        window.addEventListener("message", function (event) {
            if (event.data != null || event.data != "") {

                var message_array = event.data.split("%3B");

                if (message_array[0] == 'message_received' || message_array[0] == 'message_sent') {

                    var message_clean = decodeURIComponent(message_array[1].replace(/%25/g,'%'));

                    var urlRegex =/((\#\#\#))/ig;

                    var infraExtract = urlRegex.exec(message_clean);

                    // message_clean !== 'So, shall we begin our conversation?' && message_clean !== 'So, shall we continue our conversation?' &&

                   if (infraExtract == null && current_context.substr(0,1) == '_') {
                        if (message_clean.length > 4) {
                            $('#statement').text(message_clean);
                            $('#submitbutton').trigger('click');
                        }
                    }

                }


            }
        });
    }
    else {
        window.attachEvent("onmessage", function (event) {
            if (event.data != null || event.data != "") {
            }
        });
    }






})();
</script>




<% include statsbelow %>
</body>
</html>